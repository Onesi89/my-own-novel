{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\n구글 타임라인 데이터를 활용해 사용자의 하루 혹은 지정 기간 이동 경로를 AI가 서사 구조로 변환하여 개인화된 소설을 생성해 주는 토이 웹 서비스. 사용자는 이야기 종류나 장소별 사건에 대해 AI가 제시하는 선택지를 직접 선택하여, 자신만의 스토리를 만들어 감상할 수 있다. SNS 공유를 통해 감정적 만족과 재미를 동시에 얻는다. 모든 스토리의 주인공은 \"나\"로 지정된다.\n\n## 2. 문제 정의\n- 구글 타임라인 이용자는 자신이 이동한 경로를 시각적으로만 확인, 감정적·창의적 만족도가 낮음  \n- 일상 기록 서비스는 많지만, AI-기반 스토리텔링으로 개인 이동 데이터를 서사화하는 솔루션 부재  \n- 글쓰기 능력이나 시간 부족으로 ‘나만의 이야기’를 직접 작성하기 어려움\n\n## 3. 목표 및 목적\n- 1차 목표: 구글 타임라인 데이터를 텍스트 소설로 자동 변환  \n- 2차 목표: 작품 공유를 통해 사용자 참여 및 바이럴 확대  \n- 성공 지표  \n  - MVP 단계: 소설 생성 플로우(선택지 인터랙션 포함) 완성  \n  - SNS 공유율 30% 이상  \n\n## 4. 대상 사용자\n### 주요 사용자\n- 연령 18~45세, 구글 계정 및 타임라인 활성화 사용자  \n- 일상 기록·SNS 공유를 즐기는 MZ 세대  \n- 이동 동선이 많은 직장인, 학생, 여행객\n\n### 보조 이해관계자\n- SNS 친구 및 팔로워  \n- 마케터·브랜드(콜라보 소설 콘텐츠 활용)  \n\n## 5. 사용자 스토리\n- “구글 사용자로서, 로그인 한 번으로 내 하루 이동 경로가 소설로 변환되어 색다른 만족감을 얻고 싶다.”  \n- “여행객으로서, 일정 기간 이동 기록을 서사 형태로 보관하고 친구에게 공유하고 싶다.”  \n- “콘텐츠 크리에이터로서, 이동 경로 소설을 이어붙여 연재 형식의 블로그 시리즈를 만들고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 구글 OAuth 로그인  \n   - AC: 구글 계정으로 3초 내 로그인 가능, 실패 시 명확한 오류 메시지  \n2. 구글 타임라인 데이터 연동  \n   - AC: 사용자 승인 후 지정 날짜·기간 JSON 좌표·타임스탬프 수집  \n3. 경로→서사 AI 변환  \n    - AC: GPT-4o API 사용, 장소·시간·이동 수단을 배경·플롯·캐릭터로 변환하며, 전체 소설 분량은 짧은 웹소설 한편(5천~7천 자 이내)으로 제한  \n    - 옵션: 시작 시 사용자에게 이야기 종류(SF, 로맨스, 코미디 등)를 선택하도록 질문 제공  \n    - 각 주요 장소별로 AI가 \"여기에는 무슨 사건이 벌어졌을까요?\"와 같은 질문 및 선택지(2~3개)를 생성, 사용자가 선택하면 해당 선택지를 기반으로 창의적인 스토리 전개\n4. 소설 뷰어 및 공유  \n   - AC: 1만 자 이하 소설 렌더링, SNS 링크·이미지 카드 생성  \n5. 기간 선택·연속 소설  \n   - AC: 달력 UI로 최대 30일 범위 선택, DB에 저장하여 이어쓰기 가능\n\n### 보조 기능\n\n- 개인화 표지 이미지 생성  \n- 이전 소설 리스트·재생성\n\n## 7. 비기능 요구사항\n- 성능: 소설 생성 요청 후 10초 이내 결과 반환  \n- 보안: OAuth2, 데이터 암호화 at-rest & in-transit, GDPR 준수  \n- 사용성: 모바일 우선 반응형, 글꼴 가독성 우수  \n- 확장성: 마이크로서비스 구조, AI 모델 교체 용이  \n- 호환성: 최신 크롬·사파리·엣지, iOS/Android 브라우저 지원\n\n## 8. 기술 고려사항\n- 프론트엔드: Next.js 15.1.0 (React 19 기반), TypeScript, Turbopack (개발 서버)\n- AI 연동: Anthropic Claude 유료 API(우선 적용), OpenAI GPT-4o API (토큰 최적화, 비용 관리 포함)\n- DB: PostgreSQL (Supabase) – 소설 메타, 지속 세션  \n- 외부 API: Google Maps Timeline, Social OG Image 서비스  \n- 아키텍처: JAMstack, CDN 캐싱, ISR 활용\n\n## 9. 성공 지표\n- 제품: DAU/MAU 비율 40% 이상, 세션 당 페이지뷰 3회  \n- 비즈니스: 프리미엄 테마 업셀 결제 전환율 5%  \n- 기술: 오류율 <1%, 평균 응답 200ms (캐시 후)\n\n## 10. 일정 및 마일스톤\n- Phase 0 (2주): 요구사항 확정, 디자인 시안  \n- Phase 1 MVP (6주): 로그인, 타임라인 API, 기본 소설 생성·뷰어  \n- Phase 2 (4주): 기간 선택, SNS 공유, 번역, 로딩 최적화  \n- Phase 3 (4주): 연속 소설, 프리미엄 테마, 모바일 PWA 배포\n\n## 11. 위험 및 완화\n- Google API 정책 변경 → 정기 모니터링, 백업 모드(데모 데이터)  \n- AI 비용 급증 → 캐시·프롬프트 압축, 사용량 기반 요금제 도입  \n- AI 비용 급증(Claude API 단가에 유의) → 캐시·프롬프트 압축, 선택지 수 제한 등 토이 프로젝트에 맞는 비용 절감 방안 적용  \n\n## 12. 향후 계획\n- Wear OS 위치 데이터 연동  \n- 향후 계획은 미정이며, 토이 프로젝트 상황에 따라 유동적으로 결정함.\n",
      "writedAt": "2025-07-06T13:43:15.424Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n---\n\n## 1. 기술 총괄 요약\n- 프로젝트 개요  \n  - 구글 타임라인 위치 데이터를 수집·가공하여 AI로 개인 맞춤형 웹소설을 생성·공유하는 서비스  \n  - Jamstack 기반(Next.js 15 + Vercel) 아키텍처로 빠른 배포·스케일링 보장  \n- 핵심 기술 스택  \n  - 프론트엔드: Next.js 15, TypeScript, Tailwind CSS, shadcn UI, zustand  \n  - 백엔드(API): Next.js Route Handler + tRPC, Node.js 20  \n  - 데이터베이스: Supabase(PostgreSQL)  \n  - AI: OpenAI GPT-4o / Anthropic Claude, Vercel AI SDK  \n  - 인프라: Vercel(웹 및 서버리스) + Railway(백그라운드 워커)  \n- 핵심 기술 목표  \n  - 소설 생성 API 응답 10초 이하  \n  - 로그인 3초 이하, 시스템 오류율 1% 미만  \n  - 모바일 우선 반응형·PWA 지원  \n- 주요 전제  \n  - Google Timeline API 사용량이 일일 수천 건 이하  \n  - AI 토큰 비용은 캐싱·프롬프트 최적화로 월 100USD 내 관리  \n  - 초기 팀 규모 2~4인, DevOps 리소스 최소화 필요  \n\n---\n\n## 2. 기술 스택 아키텍처\n\n### 2.1 프론트엔드\n- 핵심 프레임워크: Next.js 15(App Router, React 19)  \n- 상태 관리: zustand + React Query(SWR 대안)  \n- 라우팅: Next.js App Router(파일 기반)  \n- UI/UX: shadcn UI, Tailwind CSS, Lucide Icons  \n- 빌드 툴: Turbopack(개발), Vercel 빌드(프로덕션)  \n\n### 2.2 백엔드(API)\n- 실행 환경: Node.js 20(LTS)  \n- 웹 프레임워크: Next.js Route Handler + tRPC(타입 안전 RPC)  \n- API 디자인: tRPC(REST 경량 래퍼 제공), SSE(WebSocket 대체)  \n- 데이터 검증: zod 스키마  \n- 미들웨어:  \n  - 인증: Clerk Google OAuth  \n  - 로깅: pino + Vercel Log Drain  \n  - 모니터링: Sentry, Vercel Analytics  \n\n### 2.3 데이터베이스·영속 계층\n- 기본 DB: Supabase(PostgreSQL 15)  \n- 스키마 설계: 정규화(3NF) + JSONB(Metadata) 혼합  \n- 캐싱: Vercel Edge, ISR, Redis(Railway) 선택적  \n- 마이그레이션: Supabase CLI + Prisma Migrate  \n- 백업·복구: Supabase Point-in-Time Recovery, 주간 외부 스냅샷  \n\n### 2.4 인프라·DevOps\n- 호스팅: Vercel(웹·서버리스), Railway(백그라운드 워커·Redis)  \n- 컨테이너: Docker(테스트·로컬 개발 용), K8s 미사용  \n- CI/CD: GitHub Actions → Vercel/Railway 자동 배포  \n- 모니터링: Vercel Analytics, Sentry, Grafana Cloud(옵션)  \n- 로그: Logtail 중앙집중, pino-pretty(로컬)  \n\n---\n\n## 3. 시스템 아키텍처 설계\n\n### 3.1 최상위 빌딩 블록\n- 프론트엔드 애플리케이션  \n  - Next.js 15 SPA/SSR 하이브리드, PWA·SEO 대응  \n- API 레이어(tRPC)  \n  - 유형 안전 엔드포인트, 입력 검증·권한 체크 담당  \n- AI 서비스 어댑터  \n  - OpenAI/Anthropic SDK 래퍼, 프롬프트 관리·토큰 최적화  \n- 구글 데이터 어댑터  \n  - Google OAuth 토큰 갱신, Timeline JSON 파싱·정규화  \n- 데이터베이스(Supabase)  \n  - 사용자·이동경로·소설 메타 및 캐시 저장  \n- 백그라운드 워커  \n  - 장문 소설 생성·이미지 카드 렌더링 등 장시간 작업 오프로딩  \n- CDN & 캐시  \n  - Vercel Edge Network, ISR, Redis(선택)  \n\n### 3.2 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    FE[Next.js Frontend] --> RPC[tRPC API]\n    RPC --> DB[(Supabase)]\n    RPC --> AI[AI Service Adapter]\n    RPC --> GAPI[Google Data Adapter]\n    AI --> Worker[Background Worker]\n```\n- FE → RPC: 클라이언트는 tRPC 로 유형 안전 호출 수행  \n- RPC → GAPI: OAuth 토큰 사용해 Timeline 데이터 수집  \n- RPC → AI: 선택지·프롬프트 전달, AI 결과 수신  \n- AI → Worker: 5초 초과 작업은 워커로 위임, 완료 시 DB 저장  \n\n### 3.3 코드 조직·규약\n- 도메인 기반 모듈: user, story, timeline, share, common  \n- 기존 폴더 구조는 유지하되, 앞으로 추가되는 모든 프론트엔드 코드와 기능은 FSD(Feature-Sliced Design) 아키텍처 원칙에 따라 분리 및 배치  \n- FSD 아키텍처: app/features, app/entities, app/shared, app/widgets 등 계층별로 기능 배치  \n- 각 FSD 레이어별로 service, model, ui, lib, api 등 세부 구조 적용  \n- 공통 컴포넌트 및 유틸은 shared 계층에 별도 모듈화  \n\n### 3.4 파일·폴더 구조\n```\n/app-root\n├── apps/\n│   ├── web/                # Next.js 15\n│   │   ├── src/\n│   │   │   ├── components/\n│   │   │   ├── domains/\n│   │   │   │   ├── story/\n│   │   │   │   ├── timeline/\n│   │   │   │   └── user/\n│   │   │   ├── pages/\n│   │   │   ├── hooks/\n│   │   │   └── utils/\n│   │   └── package.json\n│   └── worker/             # Background worker\n│       ├── src/\n│       │   ├── jobs/\n│       │   ├── services/\n│       │   └── utils/\n│       └── package.json\n├── packages/\n│   ├── api/                # tRPC routers & procedures\n│   ├── ai-adapter/\n│   ├── google-adapter/\n│   └── config/\n├── prisma/\n│   ├── schema.prisma\n│   └── migrations/\n└── infrastructure/\n    ├── docker/\n    ├── scripts/\n    └── terraform/\n\n# (FSD 적용 예시: 앞으로 추가될 프론트엔드 기능의 폴더 구조)\napps/web/src/\n├── features/        # 주요 기능 단위\n├── entities/        # 핵심 도메인/엔티티\n├── widgets/         # UI 위젯/복합 컴포넌트\n├── shared/          # 공통 모듈, 유틸, 타입 등\n```\n\n\n### 3.5 데이터 흐름·통신 패턴\n- 클라이언트 ↔ 서버: HTTPS + tRPC(JSON) 요청/응답, SSE 진행 상황 스트림  \n- DB 인터랙션: Prisma ORM, 풀링은 Supabase PgBouncer 활용  \n- 외부 통합: Google API(OAuth2)·OpenAI/Anthropic, 지수 백오프 재시도  \n- 실시간: SSE로 AI 진행률 표시, WebSocket 필요 시 soketi 도입 고려  \n- 데이터 동기화: AI 결과·선택지 캐시 후 DB 반영, stale-while-revalidate 패턴  \n\n---\n\n## 4. 성능·최적화 전략\n- Vercel Edge 캐시 + ISR로 정적·반정적 페이지 200ms 이하 렌더링  \n- AI 프롬프트 압축·요약, 토큰 절감 및 응답 시간 단축  \n- Google Timeline 결과 로컬 Redis 캐시(30분)로 API 호출 비용 절감  \n- 클라이언트 코드 스플리팅·Lazy Loading, 이미지 Next.js `<Image>` 최적화  \n\n---\n\n## 5. 구현 로드맵·마일스톤\n\n### 5.1 Phase 1: 기초(MVP) – 6주\n- 인프라: Vercel 프로젝트·Supabase 인스턴스 설정  \n- 필수 기능: Google OAuth, Timeline 수집, 기본 소설 생성·뷰어  \n- 보안: HTTPS, OAuth2 PKCE, 기본 Rate Limiting  \n- 개발 환경: Turborepo 구성, GitHub Actions CI/CD  \n- 완료 시점: 2024-Q3 Week 6  \n\n### 5.2 Phase 2: 기능 확장 – 4주\n- 고급 기능: 기간 선택·연속 소설, SNS OG 이미지 카드 생성  \n- 성능 개선: Redis 캐시, AI 백그라운드 워커 분리  \n- 보안 강화: Sentry, CSP 헤더, GDPR 데이터 삭제 API  \n- 모니터링: Grafana Cloud 대시보드 구축  \n- 완료 시점: 2024-Q4 Week 2  \n\n### 5.3 Phase 3: 스케일링·최적화 – 4주\n- 스케일링: Vercel Pro 플랜·Edge Region 최적화, Read Replica 적용  \n- 고급 통합: 결제(프리미엄 테마, TossPayments), PWA 배포  \n- 엔터프라이즈 기능: 관리자 대시보드·사용량 통계  \n- 컴플라이언스: 추가 개인정보 처리방침·감사 로그  \n- 완료 시점: 2024-Q4 Week 6  \n\n---\n\n## 6. 위험 평가·완화 전략\n\n### 6.1 기술 리스크\n| 리스크 | 설명 | 완화 방안 |\n| --- | --- | --- |\n| Google API 정책 변경 | 데이터 접근 제한 가능 | 주기적 검토, 데모 데이터 백업 모드 |\n| AI 비용 급등 | 토큰 단가 변동 | 캐싱 강화, 프롬프트 축소, 요금제 모니터링 |\n| 성능 병목 | AI 응답 지연 | 워커 분산, 비동기 SSE 진행률 |\n| 보안 취약점 | OAuth 토큰 탈취 | TLS 1.3, 토큰 암호화, 최소 권한 원칙 |\n\n### 6.2 프로젝트 리스크\n| 리스크 | 설명 | 대응책 |\n| --- | --- | --- |\n| 일정 지연 | 소규모 팀·새 기능 증가 | 스프린트 리뷰, 범위 조정 |\n| 리소스 부족 | AI·프론트 병행 개발 부담 | 우선순위 확정, 외부 라이브러리 적극 활용 |\n| 품질 저하 | 테스트 커버리지 부족 | Vitest 단위 테스트, Playwright e2e |\n\n---\n\n### 비즈니스 중심 기술 제언\n- 커뮤니티·문서 풍부한 스택 선택(Next.js·Supabase)으로 유지보수 비용 절감  \n- Vercel 무료 구간 활용, 초기 서버리스로 인프라 비용 최소화  \n- AI 사용량 캐시 정책 도입, 인당 월 1~2회 무료 · 초과 시 과금 모델 유연화  \n- 도메인 중심 코드 조직으로 기능 확장 시 리팩터링 비용 감소  \n\n---",
      "writedAt": "2025-07-06T13:43:15.424Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline Document\n\n---\n\n## 1. Project Overview\n\nThis project is a Jamstack-based web service that transforms Google Timeline location data into personalized AI-generated web novels. The architecture leverages Next.js 15 (React 19), TypeScript, Tailwind CSS, shadcn UI, zustand for state management, and tRPC for type-safe APIs. The backend utilizes Node.js 20, Supabase (PostgreSQL), Prisma ORM, and integrates with OpenAI/Anthropic AI APIs. The system is modularized using Feature-Sliced Design (FSD) principles and is optimized for scalability, maintainability, and rapid iteration. Deployment is managed via Vercel and Railway, with CI/CD through GitHub Actions.\n\n---\n\n## 2. Core Principles\n\n1. **Type Safety First:** All code MUST be fully typed using TypeScript or zod schemas.\n2. **Single Responsibility:** Each file, function, and module MUST have a single, clear purpose.\n3. **Explicit Error Handling:** All asynchronous operations and external calls MUST handle errors explicitly.\n4. **Feature Isolation:** Features MUST be separated using FSD, avoiding cross-feature dependencies.\n5. **Security by Default:** Sensitive data handling and authentication MUST adhere to least privilege and encryption best practices.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript & Next.js (Frontend and API)\n\n#### File Organization and Directory Structure\n\n- MUST follow the FSD structure: `features/`, `entities/`, `widgets/`, `shared/`.\n- Each feature/entity/widget MUST have its own folder with `model/`, `ui/`, `api/`, `lib/` subfolders as needed.\n- Shared utilities, types, and constants MUST reside in `shared/`.\n\n```typescript\n// MUST: Feature-sliced structure for a story feature\napps/web/src/features/story/\n  ├── model/\n  ├── ui/\n  ├── api/\n  └── lib/\n```\n\n#### Import/Dependency Management\n\n- MUST use absolute imports from `src/` root.\n- MUST import only what is necessary per file.\n- MUST NOT use deep relative imports (`../../../`).\n- External dependencies MUST be declared in `package.json` and imported at the top.\n\n```typescript\n// MUST: Absolute import and minimal dependency\nimport { StoryCard } from 'features/story/ui/StoryCard';\n```\n\n```typescript\n// MUST NOT: Deep relative import\nimport StoryCard from '../../../../features/story/ui/StoryCard';\n// Use absolute import instead\n```\n\n#### Error Handling Patterns\n\n- All async functions MUST use `try-catch` blocks.\n- API errors MUST be mapped to user-friendly messages.\n- Validation errors MUST leverage zod and be surfaced to the UI.\n\n```typescript\n// MUST: Explicit error handling with zod validation\nimport { z } from 'zod';\n\nconst schema = z.object({ name: z.string() });\n\nasync function fetchData(input: unknown) {\n  try {\n    const parsed = schema.parse(input);\n    // proceed with parsed data\n  } catch (error) {\n    // handle validation error\n    throw new Error('Invalid input');\n  }\n}\n```\n\n---\n\n### 3.2 Node.js (API/Backend)\n\n#### File Organization\n\n- API routes MUST be organized by domain in `packages/api`.\n- Shared adapters (AI, Google) MUST reside in dedicated packages.\n- Background jobs MUST be under `apps/worker/src/jobs`.\n\n#### Import/Dependency Management\n\n- MUST use ES modules (`import` syntax).\n- Internal modules MUST use absolute imports.\n- Circular dependencies MUST be avoided.\n\n#### Error Handling Patterns\n\n- All external API/database calls MUST be wrapped in `try-catch`.\n- Errors MUST be logged using `pino`.\n- Sensitive error details MUST NOT be exposed to clients.\n\n```typescript\n// MUST: Error logging and safe error response\nimport { logger } from 'shared/lib/logger';\n\nasync function getStory(req, res) {\n  try {\n    const story = await db.story.findById(req.params.id);\n    res.json(story);\n  } catch (error) {\n    logger.error(error);\n    res.status(500).json({ message: 'Internal server error' });\n  }\n}\n```\n\n---\n\n### 3.3 Prisma & Supabase (Database)\n\n- Prisma schema changes MUST go through migrations.\n- Models MUST use explicit types and relations.\n- Sensitive fields (e.g., OAuth tokens) MUST be stored encrypted or hashed.\n\n```prisma\n// MUST: Explicit relations and types\nmodel User {\n  id        String   @id @default(uuid())\n  email     String   @unique\n  stories   Story[]\n}\n```\n\n---\n\n### 3.4 Tailwind CSS & shadcn UI\n\n- MUST use Tailwind utility classes for layout and spacing.\n- MUST NOT use inline styles except for dynamic values.\n- Shared UI components MUST reside in `shared/ui`.\n\n---\n\n## 4. Code Style Rules\n\n### MUST Follow\n\n1. **Consistent Naming:** Use camelCase for variables and functions, PascalCase for components and classes.  \n   _Rationale: Improves readability and maintainability._\n\n2. **Strict Typing:** All functions, props, and API contracts MUST have explicit TypeScript types.  \n   _Rationale: Prevents runtime errors and improves developer experience._\n\n3. **Functional Components:** All React components MUST be functional components.  \n   _Rationale: Aligns with React 19 best practices and hooks._\n\n4. **Atomic Commits:** Each commit MUST address a single concern or feature.  \n   _Rationale: Facilitates code review and rollback._\n\n5. **Tests for Business Logic:** All core business logic (model/services/api) MUST have unit tests using Vitest.  \n   _Rationale: Ensures reliability and guards against regressions._\n\n```typescript\n// MUST: Strictly typed functional component\ntype StoryCardProps = { title: string; author: string };\n\nexport const StoryCard: React.FC<StoryCardProps> = ({ title, author }) => (\n  <div className=\"p-4 bg-white rounded\">{title} by {author}</div>\n);\n```\n\n### MUST NOT Do\n\n1. **No Multi-responsibility Files:** MUST NOT combine unrelated logic (e.g., UI, data fetching, state) in a single file.  \n   _Rationale: Violates separation of concerns, difficult to test/maintain._\n\n2. **No Implicit Any:** MUST NOT use implicit `any` types.  \n   _Rationale: Undermines type safety._\n\n3. **No Direct State Mutation:** MUST NOT mutate state directly in React/zustand.  \n   _Rationale: Causes unpredictable UI behavior._\n\n4. **No Hardcoded Strings:** MUST NOT hardcode user-facing strings; use i18n or constants.  \n   _Rationale: Facilitates localization and consistency._\n\n5. **No Logic in Render:** MUST NOT perform side effects or data fetching inside React render methods.  \n   _Rationale: Leads to performance issues and bugs._\n\n```typescript\n// MUST NOT: Multi-responsibility file\n// BAD: UI, state, and API logic in one file\nexport function StoryPage() {\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    fetch('/api/story').then(res => res.json()).then(setData);\n  }, []);\n  return <div>{data?.title}</div>;\n}\n// Split into separate files: UI, hook, and API logic\n```\n\n---\n\n## 5. Architecture Patterns\n\n### Component/Module Structure\n\n- Each feature/entity/widget MUST be a self-contained module with its own model, UI, and API logic.\n- Shared logic MUST be extracted to `shared/`.\n\n```typescript\n// MUST: Feature module structure\nfeatures/story/\n  ├── model/useStory.ts\n  ├── ui/StoryCard.tsx\n  └── api/storyApi.ts\n```\n\n### Data Flow Patterns\n\n- Frontend communicates with backend using tRPC procedures.\n- All data fetching MUST be performed in hooks or service files, NOT in UI components.\n- State updates MUST be performed via zustand stores or React hooks.\n\n```typescript\n// MUST: Data fetching in hook, not in component\nimport { useQuery } from '@tanstack/react-query';\n\nexport function useStory(id: string) {\n  return useQuery(['story', id], () => storyApi.getStory(id));\n}\n```\n\n### State Management Conventions\n\n- Global state MUST be managed via zustand.\n- Local UI state MUST use React hooks.\n- State stores MUST be colocated with their feature.\n\n```typescript\n// MUST: zustand store colocated with feature\n// features/story/model/storyStore.ts\nimport { create } from 'zustand';\n\nexport const useStoryStore = create(set => ({\n  stories: [],\n  setStories: (stories) => set({ stories }),\n}));\n```\n\n### API Design Standards\n\n- All APIs MUST be type-safe using tRPC and zod.\n- Input/output schemas MUST be validated at the boundary.\n- API errors MUST use consistent error objects.\n\n```typescript\n// MUST: tRPC procedure with zod validation\nimport { z } from 'zod';\nimport { publicProcedure } from 'packages/api/trpc';\n\nexport const getStory = publicProcedure\n  .input(z.object({ id: z.string() }))\n  .query(async ({ input }) => {\n    // fetch and return story\n  });\n```\n\n---\n\n## Example Code Snippets\n\n```typescript\n// MUST: Single-responsibility functional component\nexport function TimelineSelector({ onSelect }: { onSelect: (range: Date[]) => void }) {\n  // UI logic only\n  return <Calendar onSelect={onSelect} />;\n}\n// Data fetching and state logic must be in separate hooks or model files.\n```\n\n```typescript\n// MUST NOT: Direct state mutation\nconst store = useStoryStore.getState();\nstore.stories.push(newStory); // ❌ Do not mutate directly\n// Instead, use the provided setter\nuseStoryStore.getState().setStories([...store.stories, newStory]);\n```\n\n```typescript\n// MUST: Error handling in async API call\nasync function fetchTimeline(token: string) {\n  try {\n    const res = await fetch('/api/timeline', { headers: { Authorization: `Bearer ${token}` } });\n    if (!res.ok) throw new Error('Failed to fetch timeline');\n    return await res.json();\n  } catch (error) {\n    // Log and rethrow or handle gracefully\n    logger.error(error);\n    throw new Error('Unable to load timeline data');\n  }\n}\n```\n\n---\n\n## Quality Criteria\n\n- **Specificity:** All rules are enforceable and mapped to the project's tech stack.\n- **Justification:** Each directive is explained with rationale.\n- **Consistency:** All code MUST align with FSD and type safety principles.\n- **Practicality:** Examples illustrate correct and incorrect patterns for immediate adoption.\n\n---\n\n**This document is the mandatory reference for all code contributions to this project. Adherence is required for code reviews, CI/CD, and production releases.**",
      "writedAt": "2025-07-06T13:43:15.424Z"
    }
  ]
}